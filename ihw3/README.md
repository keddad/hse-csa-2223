# Индивидуальное ДЗ 3
Бирюлин Никита, @keddad

Вариант: 11

> Разработать программу, вычисляющую с помощью степенного ряда с точностью не хуже 0,05% значение функции 1/(1-x) для заданного параметра x


### 4 балла
* Реализована программа на C (ref.c), которая реализует заданный вариант с вводом из файла, командной строки, случайной генерацией элементов. Поддеживается режим тестирования на скорость выполнения. Реализована функция, имплементирующая ряд Тейлора для функции. Требования по точности достигаются при X ~ [-0,6; 0,6] Использование программы:

```
./ref [c|r|s|f][input_file output_file]
```

```
[keddad@fedora ihw3]$ ./ref c
0.4
1.666230
```

```
[keddad@fedora ihw3]$ ./ref r
Generated x: -0.097418
0.911230
```

```
[keddad@fedora ihw3]$ ./ref s
Generated x: -0.007615
Time spent: 1.496752
```

* Программа отдельно ассемблируется и компонуется (смотри Makefile). Сборка производится с отключенными оптимизациями (-O0) и с параметрами компилятора, обсуждавшемися на семинаре (-fno-asynchronous-unwind-tables -fcf-protection=none), для уменьшения размера ассемблерного листинга.

* Откоментированная версия программы доступна в ref_commented.S

* Тесты доступны в test_asm.py (make test для запуска, нужен установленный pytest), они проверяют, что и бинарник сгенерированный GCC, и бинарник сгенерированный из ref_commented корректно отрабатывают на наборе тестов ввод/вывод на консоль и в файл. Для тестов я проверяю, что числа совпадают с функцией, просчитанной "влоб" с точностью 1e-3.

### 5 баллов

* Аргументы передаются через параметры
* Используются локальные (на стеке) переменные, кроме констант
* В ref_commented есть комментарии о передаче аргументов в функции, и том, как они переходят из регистров на стек

### 6 баллов

"Главная" функция, которая вычисляет значение функции через ряд Тейлора, выглядит довольно страшно - там много лишних копирований, без оптимизаций код для работы с плавающей точкой явно оставляет желать лучшего. Можно переписать эту функцию руками - тут нет никаких конкретных оптимизаций, но так мы полностью убираем работу с стеком, и код заметно короче. Код доступен в ref_regopt.S. Бинарник тестируется аналогично с предьедущими.

### 7 баллов
* Код уже поддерживает ввод/вывод в/из файла.
```
./ref f input.txt output.txt
```

* Версия кода на 6 баллов, разбитая на два файла (manyfiles_a.S, manyfiles_b.S), в одном из которых main, а вдругом все остальное, успешно собирается как два отдельных обьектных файла и линкуется. Она добавлена в тесты.

### 8 баллов

* В программе есть возможность генерации случайных чисел. В этом режиме она сначала печатает случайно сгенерированное число, а потом обработанное.
```
[keddad@fedora ihw3]$ ./ref r
Generated x: 0.246159
1.326535
```

* В программе есть режим замера производительности. В этом режиме она генерирует случайное число и применяет к нему обработку из условия задачи SPEEDTEST_N (1000000 в текущей версии кода) раз. Код специально вынесен в отдельный бранч, который не использует никаких функций ввода/вывода, чтобы минимизировать его влияние на бенчмаркинг.
```
[keddad@fedora ihw3]$ ./ref s
Generated x: -0.221065
Time spent: 1.502420
```

* Проведем сравнительный анализ скорости выполнения оригинальной программы (ref) и программы с оптимизациями использования регистров (ref_regopt). Код для тестов приведен в файле bench.py (make bench для воспроизведения).

```
Binary  Average Median
ref     1.5103624500000001
ref_regopt      0.37104 0.370167
```

* Как мы видим, сравнительно простая оптимизация использования регистров, где это возможно, значительно ускоряет работу программы.

### 9 баллов

* Добавлены make-таргеты ref_speed и ref_size, которые собирают файл ref.c c опциями -O3 и -Os соответственно. Они, ожидаемо, проходят тесты.

* Улучшим скрипт bench.py. Добавим в него возможность получить размер бинарного файла и размер ассемблерного кода (просто проанализируем количество строк в листинге, сгенерированном objdump). Получим такие результаты:

```
Binary  Average Median  File size       ASM Size
ref     1.5103624500000001      1.5057395       25656   380
ref_regopt      0.37104 0.370167        25656   365
ref_size        8.500000000000001e-07   1e-06   25656   319
ref_speed       7.000000000000002e-07   1e-06   25656   347
```

* Сначала мне даже показалось что утилита для спидтеста работает неправильно. Как мы видим, с оптимизациями компилятора код работает значительно быстрее.
