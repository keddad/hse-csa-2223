# Индивидуальное ДЗ 2

Бирюлин Никита, @keddad

Вариант: 32

> Разработать программу, которая на основе анализа двух входных ASCII-строк формирует на выходе две другие строки. В первой из выводимых строк содержатся символы, которых нет во второй исходной строке. Во второй выводимой строке содержатся символы, отсутствующие в первой входной строке (разности символов). Каждый символ в соответствующей выходной строке должен встречаться только один раз.

### 4 балла
* Реализована программа на C (ref.c), которая реализует заданный вариант с вводом из файла, командной строки, случайной генерацией элементов. Поддеживается режим тестирования на скорость выполнения. Использование программы:

```
./ref [c|r|s|f] [size for r/s] [input_file output_file]
```

```
[keddad@fedora ihw1]$ ./ref r 10
Generated strings:
X-
Y`0Q."y:%
-X
"%.0:QY`y
```

```
[keddad@fedora ihw1]$ ./ref s 10
Generated strings:
#<NhaDL3
)fLiOW
Time spent: 0.043639
```

```
[keddad@fedora ihw1]$ ./ref c
abc
bjk
ac
jk
```

* Программа отдельно ассемблируется и компонуется (смотри Makefile). Сборка производится с отключенными оптимизациями (-O0) и с параметрами компилятора, обсуждавшемися на семинаре (-fno-asynchronous-unwind-tables -fcf-protection=none), для уменьшения размера ассемблерного листинга.

* Откоментированная версия программы доступна в ref_commented.S

* Тесты доступны в test_asm.py (make test для запуска, нужен установленный pytest), они проверяют, что и бинарник сгенерированный GCC, и бинарник сгенерированный из ref_commented корректно отрабатывают на наборе тестов ввод/вывод на консоль и в файл.

### 5 баллов

* Аргументы передаются через параметры
* Используются локальные (на стеке) переменные, кроме констант
* В ref_commented есть комментарии о передаче аргументов в функции, и том, как они переходят из регистров на стек

### 6 баллов

Каждая из функиций получает свои аргументы в регистрах, погружает их на стек и работает с ними из стека, как тут:
```asm
fill_chararr:
    push    rbp
    mov rbp, rsp
    sub rsp, 32
    mov QWORD PTR [rbp-24], rdi # s
    mov QWORD PTR [rbp-32], rsi # corresponding chararr
```

Это сделано потому, что без оптимизаций GCC не использует r-регистры, а обычных просто не хватает для хранения данных между вызовами библиотечных функций. Решением проблемы является премещение этих переменных в r-регистры в функциях fill_chararr, gen_anwer (там лежит большая часть логики). После записи мы для получения их обращаемся к регистрам, а не ко стеку, что должно улучшать проихводительность, особенно в циклах. Измененный код доступен в ref_regopt.S. Бинарник, который из него генерируется, добавлен к тестам. Размер программы при этом уменьшился всего на строчку.

### 7 баллов
* Код уже поддерживает ввод/вывод в/из файла.
```
./ref f input.txt output.txt
```

* Версия кода на 6 баллов, разбитая на два файла (manyfiles_a.S, manyfiles_b.S), в одном из которых main, а вдругом все остальное, успешно собирается как два отдельных обьектных файла и линкуется. Она добавлена в тесты.

### 8 баллов

* В программе есть возможность генерации случайных строк. В этом режиме она сначала печатает случайно сгенерированные строки, а потом обработанные.
```
[keddad@fedora ihw2]$ ./ref r 10
Generated strings:
uxkmGt
YHP(/I▒jC
Gkmtux
▒(/CHIPYj
```

* В программе есть режим замера производительности. В этом режиме она генерирует случайный набор данных заданной длинны и применяет к нему обработку из условия задачи SPEEDTEST_N (1000000 в текущей версии кода) раз. Код специально вынесен в отдельный бранч, который не использует никаких функций ввода/вывода, чтобы минимизировать его влияние на бенчмаркинг.
```
[keddad@fedora ihw2]$ ./ref s 100
Generated strings:
<ugly random strings>
Time spent: 0.560483

```

* Проведем сравнительный анализ скорости выполнения оригинальной программы (ref) и программы с оптимизациями использования регистров (ref_regopt). Код для тестов приведен в файле bench.py (make bench для воспроизведения).

```
Binary  Average Median  
ref     0.8883176       0.8481609999999999
ref_regopt      0.1522967       0.1155845 
```

* Как мы видим, сравнительно простая оптимизация использования регистров, где это возможно, значительно ускоряет обработку массива.

### 9 баллов

* Добавлены make-таргеты ref_speed и ref_size, которые собирают файл ref.c c опциями -O3 и -Os соответственно. Они, ожидаемо, проходят тесты.

* Улучшим скрипт bench.py. Добавим в него возможность получить размер бинарного файла и размер ассемблерного кода (просто проанализируем количество строк в листинге, сгенерированном objdump). Получим такие результаты:

```
Binary  Average Median  File size       ASM Size
ref     0.9850822199999993      0.9890005       25880   725
ref_regopt      0.09033802999999999     0.09102099999999999     25880   724
ref_size        0.8689210200000004      0.864347        25832   396
ref_speed       0.349049265     0.3507395       25832   579
```

* Интересно, что теперь, в отличии от ДЗ1, код, написанный вручную, работает не медленее оптимизированного компилятором (+- 0.2 секунды можно принять как погрешность измерений) Традиционно, любые оптимизации компилятора генерируют более компактный ассемблерный листинг.
