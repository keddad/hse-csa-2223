# Индивидуальное ДЗ 2

Бирюлин Никита, @keddad

Вариант: 32

> Разработать программу, которая на основе анализа двух входных ASCII-строк формирует на выходе две другие строки. В первой из выводимых строк содержатся символы, которых нет во второй исходной строке. Во второй выводимой строке содержатся символы, отсутствующие в первой входной строке (разности символов). Каждый символ в соответствующей выходной строке должен встречаться только один раз.

### 4 балла
* Реализована программа на C (ref.c), которая реализует заданный вариант с вводом из файла, командной строки, случайной генерацией элементов. Поддеживается режим тестирования на скорость выполнения. Использование программы:

```
./ref [c|r|s|f] [size for r/s] [input_file output_file]
```

```
[keddad@fedora ihw1]$ ./ref r 10
Generated strings:
X-
Y`0Q."y:%
-X
"%.0:QY`y
```

```
[keddad@fedora ihw1]$ ./ref s 10
Generated strings:
#<NhaDL3
)fLiOW
Time spent: 0.043639
```

```
[keddad@fedora ihw1]$ ./ref c
abc
bjk
ac
jk
```

* Программа отдельно ассемблируется и компонуется (смотри Makefile). Сборка производится с отключенными оптимизациями (-O0) и с параметрами компилятора, обсуждавшемися на семинаре (-fno-asynchronous-unwind-tables -fcf-protection=none), для уменьшения размера ассемблерного листинга.

* Откоментированная версия программы доступна в ref_commented.S

* Тесты доступны в test_asm.py (make test для запуска, нужен установленный pytest), они проверяют, что и бинарник сгенерированный GCC, и бинарник сгенерированный из ref_commented корректно отрабатывают на наборе тестов ввод/вывод на консоль и в файл.

### 5 баллов

* Аргументы передаются через параметры
* Используются локальные (на стеке) переменные, кроме констант
* В ref_commented есть комментарии о передаче аргументов в функции, и том, как они переходят из регистров на стек

### 6 баллов

Каждая из функиций получает свои аргументы в регистрах, погружает их на стек и работает с ними из стека, как тут:
```asm
fill_chararr:
    push    rbp
    mov rbp, rsp
    sub rsp, 32
    mov QWORD PTR [rbp-24], rdi # s
    mov QWORD PTR [rbp-32], rsi # corresponding chararr
    mov rax, QWORD PTR [rbp-24]
    mov QWORD PTR [rbp-8], rax
```

Это сделано потому, что без оптимизаций GCC не использует r-регистры, а обычных просто не хватает для хранения данных между вызовами библиотечных функций. Решением проблемы является премещение этих переменных в r-регистры в функциях fill_chararr, gen_anwer (там лежит большая часть логики). После записи мы для получения их обращаемся к регистрам, а не ко стеку, что должно улучшать проихводительность, особенно в циклах. Измененный код доступен в ref_regopt.S. Бинарник, который из него генерируется, добавлен к тестам.