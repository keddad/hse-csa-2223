### 1-3
Для аргументов "0", "4", "3", "1" программа возвращает 0 0 1 3, очевидно, она работает некорректно. При этом для "2 1 5 -12 3 -9" из задания все окей. Очевидно, что-то сломанно, давайте найдем что.

### 4
Запустили программу с отладчиком, не заметили ничего подозрительного на первый взгляд.

### 5
Мы знаем, что при аргументах "0 4 3 1" программа почему-то находит новый ноль, но теряет четверку. Попробуем запустить программу с отладчиком. Мы вызываем функцию сортировки с параметром размера массива равным argc. Для примера это пять. Напечатаем все пять элементов массива до вызова функции (тут пример из LLDB):

```
parray 5 a

(int *) $1 = 0x00000000004052a0 {
  (int) [0] = 0
  (int) [1] = 4
  (int) [2] = 3
  (int) [3] = 1
  (int) [4] = 0
}
```

После вызова функции:
```
(int *) $0 = 0x00000000004052a0 {
  (int) [0] = 0
  (int) [1] = 0
  (int) [2] = 1
  (int) [3] = 3
  (int) [4] = 4
}
```

Хорошо, это обьясняет проблему: реальный размер массива - 4, пять - элемент за массивом, который, по совпадению, оказался равен нулю. Видимо, на примере из условия нам повезло с "мусором" в куче, и проблема не воспроизвелась, а тут воспроизвелась. Очевидное решение - передавать как параметр size argc-1. Исправленный код находится в shell_fixed.c.