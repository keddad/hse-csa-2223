# Индивидуальное ДЗ 1

Вариант: 25

> Сформировать массив B из элементов массива A заменив все
> положительные числа значением 2, а отрицательные — увеличить на 5

### 4 балла
* Реализована программа на C (ref.c), которая реализует заданный вариант с вводом из файла, командной строки, случайной генерацией элементов. Поддеживается режим тестирования на скорость выполнения. Использование программы:

```
./ref [c|r|s|f] size_array [input_file output_file]
```

```
[keddad@fedora ihw1]$ ./ref r 10
Generated array: -151100462 -505048620 1602554128 -681920502 1996920713 -1212085690 531078479 1494887747 1726283910 1463445293 
-151100457 -505048615 2 -681920497 2 -1212085685 2 2 2 2 
```

```
[keddad@fedora ihw1]$ ./ref s 10
Generated array: -534599445 -138154927 16738682 -483896265 1088237131 1910601867 -343543361 -2074691600 1303998665 -2134536443 
Time spent: 0.002762
```

```
[keddad@fedora ihw1]$ ./ref c 10
-1 -2 -3 -4 -5 1 2 3 4 5
4 3 2 1 0 2 2 2 2 2
```

* Программа отдельно ассемблируется и компонуется (смотри Makefile). Сборка производится с отключенными оптимизациями (-O0) и с параметрами компилятора, обсуждавшемися на семинаре (-fno-asynchronous-unwind-tables -fcf-protection=none), для уменьшения размера ассемблерного листинга.

* Откоментированная версия программы доступна в ref_commented.S

* Тесты доступны в test.py (make test для запуска, нужен установленный pytest), они проверяют, что и бинарник сгенерированный GCC, и бинарник сгенерированный из ref_commented корректно отрабатывают на наборе тестов ввод/вывод на консоль и в файл. В процессе тестирования был обнаружен segfault при вызове fopen, он исправлен.
generate_arr
### 5 баллов

* Аргументы передаются через параметры
* Используются локальные (на стеке) переменные, кроме констант
* В ref_commented есть комментарии о передаче аргументов в функции, и том, как они переходят из регистров на стек

### 6 баллов

Каждая из функиций получает свои аргументы в регистрах, погружает их на стек и работает с ними из стека, как тут:
```asm
read_arr:
    push    rbp
    mov rbp, rsp
    sub rsp, 48 # Выделяем место на стеке под переменные
    mov DWORD PTR [rbp-20], edi  # size
    mov QWORD PTR [rbp-32], rsi # *Arr
    mov QWORD PTR [rbp-40], rdx # FILE*
    mov DWORD PTR [rbp-4], 0 # i
```

Это сделано потому, что без оптимизаций GCC не использует r-регистры, а обычных просто не хватает для хранения данных между вызовами библиотечных функций. Решением проблемы является премещение этих переменных в r-регистры в функциях read_arr, write_arr, generate_arr и process. После записи мы для получения их обращаемся к регистрам, а не ко стеку, что должно улучшать проихводительность, особенно в циклах. Измененный код доступен в ref_regopt.S. Бинарник, который из него генерируется, добавлен к тестам.

### 7 баллов
* Код уже поддерживает ввод/вывод в/из файла.
```
./ref f 10 input.txt output.txt
```

* Версия кода на 6 баллов, разбитая на два файла (manyfiles_a.S, manyfiles_b.S), в одном из которых main, а вдругом все остальное, успешно собирается как два отдельных обьектных файла и линкуется. Она добавлена в тесты.
