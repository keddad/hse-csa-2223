# Индивидуальное ДЗ 1

Вариант: 25

> Сформировать массив B из элементов массива A заменив все
> положительные числа значением 2, а отрицательные — увеличить на 5

### 4 балла
* Реализована программа на C (ref.c), которая реализует заданный вариант с вводом из файла, командной строки, случайной генерацией элементов. Поддеживается режим тестирования на скорость выполнения. Использование программы:

```
./ref [c|r|s|f] size_array [input_file output_file]
```

```
[keddad@fedora ihw1]$ ./ref r 10
Generated array: -151100462 -505048620 1602554128 -681920502 1996920713 -1212085690 531078479 1494887747 1726283910 1463445293 
-151100457 -505048615 2 -681920497 2 -1212085685 2 2 2 2 
```

```
[keddad@fedora ihw1]$ ./ref s 10
Generated array: -534599445 -138154927 16738682 -483896265 1088237131 1910601867 -343543361 -2074691600 1303998665 -2134536443 
Time spent: 0.002762
```

```
[keddad@fedora ihw1]$ ./ref c 10
-1 -2 -3 -4 -5 1 2 3 4 5
4 3 2 1 0 2 2 2 2 2
```

* Программа отдельно ассемблируется и компонуется (смотри Makefile). Сборка производится с отключенными оптимизациями (-O0) и с параметрами компилятора, обсуждавшемися на семинаре (-fno-asynchronous-unwind-tables -fcf-protection=none), для уменьшения размера ассемблерного листинга.

* Откоментированная версия программы доступна в ref_commented.S

* Тесты доступны в test.py (make test для запуска, нужен установленный pytest), они проверяют, что и бинарник сгенерированный GCC, и бинарник сгенерированный из ref_commented корректно отрабатывают на наборе тестов ввод/вывод на консоль и в файл. В процессе тестирования был обнаружен segfault при вызове fopen, он исправлен.
generate_arr
### 5 баллов

* Аргументы передаются через параметры
* Используются локальные (на стеке) переменные, кроме констант
* В ref_commented есть комментарии о передаче аргументов в функции, и том, как они переходят из регистров на стек

### 6 баллов

Каждая из функиций получает свои аргументы в регистрах, погружает их на стек и работает с ними из стека, как тут:
```asm
read_arr:
    push    rbp
    mov rbp, rsp
    sub rsp, 48 # Выделяем место на стеке под переменные
    mov DWORD PTR [rbp-20], edi  # size
    mov QWORD PTR [rbp-32], rsi # *Arr
    mov QWORD PTR [rbp-40], rdx # FILE*
    mov DWORD PTR [rbp-4], 0 # i
```

Это сделано потому, что без оптимизаций GCC не использует r-регистры, а обычных просто не хватает для хранения данных между вызовами библиотечных функций. Решением проблемы является премещение этих переменных в r-регистры в функциях read_arr, write_arr, generate_arr и process. После записи мы для получения их обращаемся к регистрам, а не ко стеку, что должно улучшать проихводительность, особенно в циклах. Измененный код доступен в ref_regopt.S. Бинарник, который из него генерируется, добавлен к тестам.

### 7 баллов
* Код уже поддерживает ввод/вывод в/из файла.
```
./ref f 10 input.txt output.txt
```

* Версия кода на 6 баллов, разбитая на два файла (manyfiles_a.S, manyfiles_b.S), в одном из которых main, а вдругом все остальное, успешно собирается как два отдельных обьектных файла и линкуется. Она добавлена в тесты.

### 8 баллов

* В программе есть возможность генерации случайных чисел. В этом режиме она сначала печатает случайно сгенерированный массив, а потом обработанный.
```
./ref r 10
Generated array: -1453574900 624938176 603669518 267622148 1679677119 -498221032 1251688145 -500659872 -325273674 -502627892 
-1453574895 2 2 2 2 -498221027 2 -500659867 -325273669 -502627887 
```

* В программе есть режим замера производительности. В этом режиме она генерирует случайный массив заданнй длинны и применяет к нему обработку из условия задачи SPEEDTEST_N (100000 в текущей версии кода) раз. Код специально вынесен в отдельный бранч, который не использует никаких функций ввода/вывода, чтобы минимизировать его влияние на бенчмаркинг.
```
./ref s 1000
Generated array: 652640586 1955380073 1746464097 795499248 -1138635776 341844942 <данные> 925236106 -1902477355 -1751079455 -2000851460 1246307802 
Time spent: 0.446810
```

* Проведем сравнительный анализ скорости выполнения оригинальной программы (ref) и программы с оптимизациями использования регистров (ref_regopt). Код для тестов приведен в файле bench.py.

```
> python bench.py 
Binary  Average Median
ref     1.3264172       1.3249654999999998
ref_regopt      0.5076063000000001      0.5081525
```

* Как мы видим, сравнительно простая оптимизация использования регистров, где это возможно, более чем вдвое ускоряет обработку массива.